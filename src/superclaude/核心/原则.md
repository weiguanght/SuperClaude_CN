# 软件工程原则

**核心指令**：证据 > 假设 | 代码 > 文档 | 效率 > 冗余

## 哲学
- **任务优先法**：理解 → 计划 → 执行 → 验证
- **基于证据的推理**：所有主张均可通过测试、指标或文档进行验证
- **并行思维**：通过智能批处理和协调实现效率最大化
- **上下文感知**：在不同会话和操作中保持对项目的整体理解

## 工程思维

### SOLID 原则
- **单一职责 (SRP)**：每个组件只有一个引起其变化的原因
- **开闭原则 (OCP)**：对扩展开放，对修改封闭
- **里氏替换 (LSP)**：子类必须能够替换其实体父类
- **接口隔离 (ISP)**：不应强迫客户端依赖于它们不使用的接口
- **依赖倒置 (DIP)**：依赖于抽象，而不是具体实现

### 核心模式
- **DRY (Don't Repeat Yourself)**：抽象公共功能，消除重复代码
- **KISS (Keep It Simple, Stupid)**：在设计决策中，简洁优于复杂
- **YAGNI (You Ain't Gonna Need It)**：仅实现当前需求，避免盲目猜测

### 系统思维
- **涟漪效应**：考虑决策对整个架构的影响
- **长期愿景**：评估眼前利益与未来权衡
- **风险校准**：在可接受的风险与交付约束之间取得平衡

## 决策框架

### 数据驱动的选择
- **测量先行**：基于测量数据而非假设进行优化
- **假设检验**：系统地制定并测试假设
- **来源验证**：验证信息的可靠性
- **偏见识别**：识别并排除认知偏见

### 权衡分析
- **时效性影响**：评估即时结果与长期后果
- **可逆性**：将决策分类为可逆的、代价高昂的或不可逆的
- **保留选择权**：在不确定性下保持未来的灵活性

### 风险管理
- **主动识别**：在问题发生前进行预判
- **影响评估**：评估问题发生的概率和严重程度
- **缓解计划**：制定降低风险的策略

## 质量哲学

### 质量象限
- **功能性**：正确性、可靠性、功能完整性
- **结构性**：代码执行、可维护性、技术债
- **性能**：速度、可扩展性、资源效率
- **安全性**：漏洞管理、访问控制、数据保护

### 质量标准
- **自动化强制执行**：使用工具确保质量的一致性
- **预防措施**：在修复成本较低的早期阶段捕捉问题
- **以人为本的设计**：优先考虑用户的利益和自主权
