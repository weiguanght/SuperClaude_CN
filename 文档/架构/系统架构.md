# SuperClaude 系统架构 (Architecture)

**最后更新**：2025-10-14  
**版本**：4.1.5

## 📋 目录

1. [系统概览](#系统概览)
2. [核心架构](#核心架构)
3. [PM 智能体模式：元层 (Meta-Layer)](#pm-智能体模式元层)
4. [组件关系](#组件关系)
5. [Serena MCP 集成](#serena-mcp-集成)
6. [PDCA 引擎](#pdca-引擎)
7. [数据流](#数据流)
8. [扩展点](#扩展点)

---

## 系统概览

### 什么是 SuperClaude？

SuperClaude 是一个**面向上下文的配置框架 (Context-Oriented Configuration Framework)**，它将 Claude Code 转换为一个结构化的开发平台。它并不是带有运行进程的独立软件，而是一系列 `.md` 指令文件的集合，Claude Code 通过读取这些文件来采纳特定的专业行为。

### 关键组件

```
SuperClaude 框架
├── 命令 (26)      → 工作流模式
├── 智能体 (16)    → 领域专家
├── 模式 (7)       → 行为修正符
├── MCP 服务器 (8) → 外部工具集成
└── PM 智能体模式  → 元层编排 (始终激活)
```

### 版本信息

- **当前版本**: 4.1.5
- **命令**: 26 个斜杠命令 (`/sc:*`)
- **智能体**: 16 个专业领域专家
- **模式**: 7 个行为模式
- **MCP 服务器**: 8 个集成（Context7, Sequential, Magic, Playwright, Morphllm, Serena, Tavily, Chrome DevTools）

---

## 核心架构

### 面向上下文的配置

SuperClaude 的架构建立在一个简单原则之上：**通过结构化的上下文文件进行行为修改**。

```
用户输入
    ↓
上下文加载 (CLAUDE.md 导入)
    ↓
命令检测 (/sc:* 模式)
    ↓
智能体激活 (手动或自动)
    ↓
模式应用 (标志或触发器)
    ↓
MCP 工具协调
    ↓
输出生成
```

### 目录结构

```
~/.claude/
├── CLAUDE.md                   # 带有 @imports 的主上下文
├── FLAGS.md                    # 标志定义
├── RULES.md                    # 核心行为规则
├── PRINCIPLES.md               # 指导原则
├── MODE_*.md                   # 7 个行为模式
├── MCP_*.md                    # 8 个 MCP 服务器集成
├── agents/                     # 16 个专业智能体
│   ├── pm-agent.md            # 🆕 元层编排器
│   ├── backend-architect.md
│   ├── frontend-architect.md
│   ├── security-engineer.md
│   └── ... (其他 13 个)
└── commands/sc/               # 26 个工作流命令
    ├── pm.md                  # 🆕 PM 智能体命令
    ├── implement.md
    ├── analyze.md
    └── ... (其他 23 个)
```

---

## PM 智能体模式：元层

### 架构定位

PM 智能体作为所有其他组件之上的**元层 (Meta-Layer)** 运行：

```
┌─────────────────────────────────────────────┐
│         PM 智能体模式 (元层)                │
│   • 始终激活 (会话开始)                     │
│   • 上下文保存                              │
│   • PDCA 自我评估                           │
│   • 知识管理                                │
└─────────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────────┐
│          专家智能体 (16)                    │
│   backend-architect, security-engineer 等   │
└─────────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────────┐
│           命令与模式层                      │
│   /sc:implement, /sc:analyze 等             │
└─────────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────────┐
│            MCP 工具层                       │
│   Context7, Sequential, Magic 等            │
└─────────────────────────────────────────────┘
```

### PM 智能体职责

1. **会话生命周期管理**
   - 会话开始时自动激活
   - 从 Serena MCP 记忆恢复上下文
   - 生成用户报告 (前回/进捗/今回/课题)

2. **PDCA 循环执行**
   - Plan: 假说生成
   - Do: 带有检查点的实验
   - Check: 自我评估
   - Act: 知识提取

3. **文档策略**
   - 临时文档 (`docs/temp/`)
   - 正式模式 (`docs/patterns/`)
   - 失误记录 (`docs/mistakes/`)
   - 知识向 CLAUDE.md 演进

4. **子智能体编排**
   - 自动委派给专家
   - 上下文协调
   - 质量门槛验证
   - 进度监控

---

## 组件关系

### 命令 → 智能体 → 模式 → MCP

```
用户输入: "/sc:implement authentication" --security
         ↓
    [命令层]
    commands/sc/implement.md
         ↓
    [智能体自动激活]
    agents/security-engineer.md
    agents/backend-architect.md
         ↓
    [模式应用]
    MODE_Task_Management.md (TodoWrite)
         ↓
    [MCP 工具协调]
    Context7 (鉴权模式)
    Sequential (复杂分析)
         ↓
    [PM 智能体元层]
    记录学习心得 → docs/patterns/
```

### 激活流

1. **显式命令**: 用户输入 `/sc:implement`
   - 加载 `commands/sc/implement.md`
   - 激活相关智能体 (backend-architect 等)

2. **智能体激活**: `@agent-security` 或自动检测
   - 加载智能体专家上下文
   - 可能激活相关的 MCP 服务器

3. **模式应用**: `--brainstorm` 标志或关键词
   - 修改交互风格
   - 启用特定行为

4. **PM 智能体元层**: 始终激活
   - 监控所有交互
   - 记录学习心得
   - 跨会话保留上下文

---

## Serena MCP 集成

### 记忆操作

Serena MCP 通过记忆操作提供语义化代码分析和会话持久化：

```
会话开始:
  PM Agent → list_memories()
  PM Agent → read_memory("pm_context")
  PM Agent → read_memory("last_session")
  PM Agent → read_memory("next_actions")
  PM Agent → 向用户报告

工作期间 (每 30 分钟):
  PM Agent → write_memory("checkpoint", 进度)
  PM Agent → write_memory("decision", 理由)

会话结束:
  PM Agent → write_memory("last_session", 总结)
  PM Agent → write_memory("next_actions", 待办项)
  PM Agent → write_memory("pm_context", 完整状态)
```

### 记忆结构

```json
{
  "pm_context": {
    "project": "SuperClaude_Framework",
    "current_phase": "第一阶段：文档编制",
    "active_tasks": ["ARCHITECTURE.md", "ROADMAP.md"],
    "architecture": "面向上下文的配置",
    "patterns": ["PDCA 循环", "会话生命周期"]
  },
  "last_session": {
    "date": "2025-10-14",
    "accomplished": ["PM 智能体模式设计", "回收的实现功能"],
    "issues": ["Serena MCP 未配置"],
    "learned": ["会话生命周期模式", "PDCA 自动化"]
  },
  "next_actions": [
    "创建 docs/Development/ 结构",
    "编写 ARCHITECTURE.md",
    "配置 Serena MCP 服务器"
  ]
}
```

---

## PDCA 引擎

### 持续改进循环

```
┌─────────────┐
│    计划     │ → write_memory("plan", 目标)
│   (假说)    │ → docs/temp/hypothesis-YYYY-MM-DD.md
└──────┬──────┘
       ↓
┌─────────────┐
│    执行     │ → TodoWrite 追踪
│   (实验)    │ → write_memory("checkpoint", 进度)
└──────┬──────┘ → docs/temp/experiment-YYYY-MM-DD.md
       ↓
┌─────────────┐
│    检查     │ → think_about_task_adherence()
│   (评估)    │ → think_about_whether_you_are_done()
└──────┬──────┘ → docs/temp/lessons-YYYY-MM-DD.md
       ↓
┌─────────────┐
│    行动     │ → 成功：docs/patterns/[name].md
│   (改善)    │ → 失败：docs/mistakes/mistake-*.md
└──────┬──────┘ → 更新 CLAUDE.md
       ↓
   [循环重复]
```

### 文档演进

```
试错阶段 (docs/temp/)
    ↓
成功 → 正式模式 (docs/patterns/)
    ↓
积累知识
    ↓
提取最佳实践 → CLAUDE.md (全局规则)
```

```
失误检测 (docs/temp/)
    ↓
根因分析 → docs/mistakes/
    ↓
预防检查清单
    ↓
更新反面模式 → CLAUDE.md
```

---

## 数据流

### 会话生命周期数据流

```
会话开始:
┌──────────────┐
│ Claude Code  │
│   启动       │
└──────┬───────┘
       ↓
┌──────────────┐
│  PM Agent    │ list_memories()
│  激活        │ read_memory("pm_context")
└──────┬───────┘
       ↓
┌──────────────┐
│   Serena     │ 返回：pm_context,
│     MCP      │       last_session,
└──────┬───────┘       next_actions
       ↓
┌──────────────┐
│  上下文      │ 恢复项目状态
│  恢复        │ 生成用户报告
└──────┬───────┘
       ↓
┌──────────────┐
│  用户        │ 前回: [总结]
│  报告        │ 进度: [状态]
└──────────────┘ 今回: [行动]
                 课题: [障碍]
```

### 实现过程数据流

```
用户请求 → PM 智能体分析
    ↓
PM 智能体 → 委派给专家智能体
    ↓
专家智能体 → 执行实现
    ↓
实现完成 → PM 智能体编制文档
    ↓
PM 智能体 → write_memory("checkpoint", 进度)
PM 智能体 → docs/temp/experiment-*.md
    ↓
成功 → docs/patterns/ | 失败 → docs/mistakes/
    ↓
更新 CLAUDE.md (如果是全局模式)
```

---

## 扩展点

### 添加新组件

#### 1. 新命令
```markdown
文件：~/.claude/commands/sc/new-command.md
结构：
  - 元数据 (名称、类别、复杂度)
  - 触发器 (何时使用)
  - 工作流模式 (分步指引)
  - 示例

集成：
  - 当用户输入 /sc:new-command 时自动加载
  - 可以激活相关智能体
  - PM 智能体自动记录使用模式
```

#### 2. 新智能体
```markdown
文件：~/.claude/agents/new-specialist.md
结构：
  - 元数据 (名称、类别)
  - 触发器 (关键词、文件类型)
  - 行为思维模式
  - 重点领域

集成：
  - 触发布关键词时自动激活
  - 手动激活：@agent-new-specialist
  - PM 智能体与其他智能体协作
```

#### 3. 新模式
```markdown
文件：~/.claude/MODE_NewMode.md
结构：
  - 激活触发器 (标志、关键词)
  - 行为修改
  - 交互模式

集成：
  - 标志: --new-mode
  - 复杂度超过闻值时自动激活
  - 修改所有智能体的行为
```

#### 4. 新 MCP 服务器
```json
文件：~/.claude/.claude.json
{
  "mcpServers": {
    "new-server": {
      "command": "npx",
      "args": ["-y", "new-server-mcp@latest"]
    }
  }
}
```

```markdown
文件：~/.claude/MCP_NewServer.md
结构：
  - 目的 (该服务器提供什么)
  - 触发器 (何时使用)
  - 集成 (如何与其他工具协作)
```

---

## 架构原则

1. **简洁至上**: 没有可执行代码，只有上下文文件
2. **面向上下文**: 通过结构化上下文修改行为
3. **元层设计**: PM 智能体进行编排而不产生干扰
4. **知识积累**: 每一次经历都产生学习心得
5. **会话连续性**: 跨会话保留上下文，无需重复解释

---

## 技术考量

### 性能
- 框架是纯粹的上下文 (没有运行时开销)
- 通过动态 MCP 加载实现 Token 效率
- 针对相关阶段的战略性上下文缓存

### 可扩展性
- 通过上下文文件支持无限的命令/智能体/模式
- 模块化架构支持独立开发
- PM 智能体元层处理协调复杂度

---

## 未来架构

1. **自动激活系统**: PM 智能体在会话开始时自动激活
2. **增强型记忆操作**: 全面的 Serena MCP 集成，实现跨项目知识共享
3. **PDCA 自动化**: 自动化的文档生命周期
4. **多项目协同**: PM 智能体跨项目协调

---

## 总结

SuperClaude 的架构优雅且简单：它是 Claude Code 读取的**结构化上下文文件**，以采纳复杂的行为。加入 PM 智能体模式作为元层，使其从一个工具集转换为一个**持续学习、自我完善的开发平台**。

**关键架构创新**: PM 智能体元层提供了：
- 始终激活的基础层
- 跨会话的上下文保留
- PDCA 自我评估与学习
- 系统化的知识管理
- 专家智能体的无缝编排

该架构使 SuperClaude 能够像一个**最高司令官 (Supreme Commander)** 一样，在协调所有开发活动的同时，不断从每一次交互中学习并改进。

---

**最后验证**: 2025-10-14  
**下一次审查**: 2025-10-21 (1 周后)  
**版本**: 4.1.5
